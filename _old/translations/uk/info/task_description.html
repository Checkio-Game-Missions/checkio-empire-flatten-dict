<p>
    Ніколі дуже подобається класифікувати усе, що потрапило йому на очі.
    Якось на його день народження Стефан подарував йому пристрій для маркування, та згодом
    роботи витратили багато часу відшкрябуючи наклейки з усіх поверхонь на кораблі.
    З того часу він класифікуе реагенти у своїй лабораторії
    книги в бібліотеці та нотатки на дошці.
    Але потім він дізнався про <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict">словники</a>, в Python
    та зробив класифікацію усіх можливих конфігурацій для дронів Софії.
    Тепер файли організовані у структуру із великою кільлістью вкладень,
	але дронам Софії це не довподоби. Давайте спробуємо допомогти Софії зробити ці словники більш простими.
</p>

<p>
   	Словники у Python - це дуже зручні типи данних для зберігання, та обробки будь яких конфігурацій.
    Вони дозволяють зберігати данні за допомогою ключів для створення структури з багатьма вкладеннями.
    Маємо словник, в якому ключами є рядки, а значення по ключах являє собою рядки або словники.
    Ціль завдання - спростити структуру словника зробивши її плоскою, але треба зберегти зв'язки по ключах.
    Результатом повинен стати словник без вкладених словників.
    Ключі мають містити шляхи, які складаються із батьківських ключей оригінального словника.
    Ці ключі у шляхах повинні розділятися між собою за допомогою символа "/".
	Якщо значення за ключом є пустий словник, то таке значення повинне бути замінене на рядок у вигляді ("")
    Давайте поглянемо на приклад: 
</p>
<pre class="brush: python">
{
    "name": {
        "first": "One",
        "last": "Drone"
    },
    "job": "scout",
    "recent": {},
    "additional": {
        "place": {
            "zone": "1",
            "cell": "2"}
    }
}
</pre>
<p>
    Результат повинен бути:
</p>
<pre class="brush: python">
{"name/first": "One",           #one parent
 "name/last": "Drone",
 "job": "scout",                #root key
 "recent": "",                  #empty dict
 "additional/place/zone": "1",  #third level
 "additional/place/cell": "2"}
</pre>

<p>
    Софія вже написала власний код для цього завдання, але її код містить дефект.

    <strong>Вам потрібно знайти та виправити цей дефект.</strong>
</p>

<p>
    <strong>Вхідні дані: </strong> Оригінальний словник із вкладеними словниками як тип (dict).
</p>

<p>
    <strong>Вихідні дані: </strong> Плоский словник як тип (dict).
</p>


<div class="for_info_only">
    <p>
        <strong>Приклад:</strong>
    </p>
    <pre class="brush: python">
flatten({"key": "value"}) == {"key": "value"}
flatten({"key": {"deeper": {"more": {"enough": "value"}}}}) == {"key/deeper/more/enough": "value"}
flatten({"empty": {}}) == {"empty": ""}
    </pre>
</div>

<p class="for_info_only">
    <strong>Як це використовується: </strong>
    Ця концепція може бути корисною, якщо вам потрібно розібрати конфігураційні файли, або 
	для систем предків - нащадків де потрібно спростити структуру, чи для будь яких файлових структур.
    Ви можете з легкістю модифікувати цю ідею для ваших власних потреб.
    Крім того, це корисний навик для читання коду та пошуку дефектів.
</p>

<p>
    <strong>Передумови:</strong><br>
    <strong>Ключі</strong> в словнику - не порожні рядки.<br>
    <strong>Значення</strong> в словнику рядки які складаються з інших словників.<br>
    root_dictionary != {}<br>
</p>
